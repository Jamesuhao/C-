//#1杨辉三角的变形问题
#if 0
/*
题目描述
			1

		 1  1  1

	  1  2  3  2  1

   1  3  6  7  6  3  1

1  4  10 16 19  16 10  4  1

以上三角形的数阵，第一行只有一个数1，
以下每行的每个数，是恰好是它上面的数，左上角数到右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。
求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3。
输入n(n <= 1000000000)
输入描述:
输入一个int整数
输出描述:
输出返回的int值
示例1
输入
4
输出
3
*/
#include<iostream>
#include<vector>
using namespace std;
int main()
{
	int n, m;
	while (cin >> n)
	{
		//二维数组为n行m列(杨辉三角)
		m = 2 * n - 1;
		vector<vector<int>> vec(n, vector<int>(m, 0));
		//杨辉三角中第一行第一个元素位于总行数减一的位置(整个三角最中间的位置)
		vec[0][n - 1] = 1;
		//向二维数组中填充杨辉三角数据
		for (int i = 1; i < n; ++i)
		{
			for (int j = 0; j < m; ++j)
			{
				//当前元素等于其上方[i-1][j]位置元素、左上角[i-1][j-1]位置元素、右上角[i-1][j+1]位置元素之和
				vec[i][j] = vec[i - 1][j] + vec[i - 1][j - 1] + vec[i - 1][j + 1];
			}
		}
		int i = 0;
		//遍历二维数组的第n行，寻找偶数
		for (i = 0; i < m; ++i)
		{
			//当前元素不为0且为偶数
			if (vec[n - 1][i] % 2 == 0 && vec[n - 1][i] != 0)
			{
				//输出其下标
				cout << i + 1 << endl;
				break;
			}
		}
		//当i==m时，遍历完毕，未找到偶数
		if (i == m)
		{
			cout << -1 << endl;
		}
	}
	return 0;
}
#endif

//#2超长正整数相加
#if 0
/*
题目描述
请设计一个算法完成两个超长正整数的加法。
输入描述:
输入两个字符串数字
输出描述 :
输出相加后的结果，string型
示例1
输入
99999999999999999999999999999999999999999999999999
1
输出
100000000000000000000000000000000000000000000000000
解题思路：
加法运算，每一位的值等于当前对应位的两数之和+进位。由于是加法，所以当前位的和最多是19（9 + 9 +进位1)，
所以产生的进位最多为1。故：
第一步：计算对应位的和，对应位相加 + 上一位的进位
第二步：更新当前位的值， 和 % 10 ，把值转成字符（和 - '0'）存入字符结果中
第三步：更新进位， 和 / 10， 然后计算下一位的值
最后一步：如果计算完之后，进位为1，说明最高位产生了进位，所以需要再加一位，才是最后的结果。
*/
#include<iostream>
#include<string>
using namespace std;
int main()
{
	string str1, str2;
	while (cin >> str1 >> str2)
	{
		//补齐，给数字较小的前补0，使得两个数字长度相同
		while (str1.size() > str2.size())
		{
			str2 = "0" + str2;
		}
		while (str1.size() < str2.size())
		{
			str1 = "0" + str1;
		}
		//tmp保存当前位相加后的数值，carry保存进位
		int tmp = 0, carry = 0;
		for (int i = str1.size() - 1; i >= 0; --i)
		{
			//计算对应位的和，对应位相加 + 上一位的进位
			tmp = str1[i] - '0' + str2[i] - '0' + carry;
			//更新当前位的值：和 % 10 ，把值转成字符存入字符结果中
			str1[i] = tmp % 10 + '0';
			//更新进位
			if (tmp / 10)
			{
				carry = 1;
			}
			else
			{
				carry = 0;
			}
		}
		//判断是否需要向高位进位
		if (carry)
		{
			str1 = "1" + str1;
		}
		cout << str1 << endl;
	}
	return 0;
}
#endif