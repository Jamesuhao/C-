//#1
#if 0
/*
请编写一个函数，将两个数字相加。不得使用+或其他算数运算符。
给定两个int A和B。请返回A＋B的值
测试样例：
1,2
返回：3
解题思路：
1.发散思维：
对于数的运算，除了十进制的四则运算外，就只有二进制的位运算了。
2.分析十进制加法的运算规则
(1)各位相加，高位用0补
(2)进位:10
(3)将(1)(2)得到的结果相加
3.使用位运算模拟这个过程
(1)各位相加(不考虑进位)：1+1=0 0+0=0 1+0=1 0+1=1  可以发现这就是异或的运算法则
(2)进位：1+0，0+1，0+0都不会有进位，只有1+1时会有进位，这就是与运算的运算法则，
二进制的进位就是向高一位进1，本位为0，这也就是左移的运算规则，
所以进位就是先与再左移
(3)将(1)(2)的结果相加：
不断进行循环或者递归(1)(2)两步，直至不会产生进位为止。
*/
#include<iostream>
using namespace std;
int add(int a, int b)
{
	if (b == 0)
		return a;
	//sum保存两者的和
	int sum = a ^ b;
	//carry保存进位
	int carry = (a & b) << 1;
	//递归过程中，当进位为0时即停止
	return add(sum, carry);
}
#endif

//#2
#if 0
/*
题目描述
请编写一个函数（允许增加子函数），计算n x m的棋盘格子（n为横向的格子数，m为竖向的格子数）
沿着各自边缘线从左上角走到右下角，总共有多少种走法，要求不能走回头路，
即：只能往右和往下走，不能往左和往上走。
输入描述:
输入两个正整数
输出描述:
返回结果
示例1
输入
2
2
输出
6
*/
#include<iostream>
using namespace std;
int number(int n, int m)
{
	if (n > 1 && m > 1)
		return number(n - 1, m) + number(n, m - 1);
	else if ((n == 1 && m >= 1) || (n >= 1 && m == 1))
		return n + m;
}
int main()
{
	int a, b;
	while (cin >> a >> b)
		cout << number(a, b) << endl;
	return 0;
}
#endif